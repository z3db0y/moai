(function(a,b){"object"==typeof exports&&"undefined"!=typeof module?b(exports):"function"==typeof define&&define.amd?define(["exports"],b):(a=a||self,b(a.msgpackr={}))})(this,function(a){'use strict';var b=Math.floor;function c(){try{if(!K.trusted&&!S){let a=E.sharedLength||0;a<E.length&&(E.length=a)}let a;if(K.randomAccessStructure&&64>C[J]&&R){let b=(C[J++]<<8)+C[J++];a=R(C,J,D,E[b-64]||g()[b-64],K),J=D}else a=e();if(G&&(// bundled strings to skip past
J=G.postBundlePosition),J==D)E.restoreStructures&&d(),E=null,C=null,H&&(H=null);else if(J>D)// over read
throw new Error("Unexpected end of MessagePack data");else if(!S)throw new Error("Data read, but end of buffer not reached "+JSON.stringify(a).slice(0,100));// else more to read, but we are reading sequentially, so don't clear source yet
return a}catch(a){throw E.restoreStructures&&d(),r(),(a instanceof RangeError||a.message.startsWith("Unexpected end of buffer")||J>D)&&(a.incomplete=!0),a}}function d(){for(let a in E.restoreStructures)E[a]=E.restoreStructures[a];E.restoreStructures=null}function e(){let a=C[J++];if(160>a){if(!(128>a)){if(!(144>a)){a-=144;let b=Array(a);for(let c=0;c<a;c++)b[c]=e();return K.freezeData?Object.freeze(b):b}if(a-=128,K.mapsAsObjects){let b={};for(let c=0;c<a;c++)b[p()]=e();return b}else{let b=new Map;for(let c=0;c<a;c++)b.set(e(),e());return b}}else if(64>a)return a;else{let b=E[63&a]||K.getStructures&&g()[63&a];return b?(b.read||(b.read=f(b,63&a)),b.read()):a}}else if(192>a){// fixstr
let b=a-160;if(M>=J)return F.slice(J-L,(J+=b)-L);if(0==M&&140>D){// for small blocks, avoiding the overhead of the extract call is helpful
let a=16>b?l(b):k(b);if(null!=a)return a}return X(b)}else{let b;switch(a){case 192:return null;case 193:return G?(b=e(),0<b?G[1].slice(G.position1,G.position1+=b):G[0].slice(G.position0,G.position0-=b)):Q;// "never-used", return special object to denote that
case 194:return!1;case 195:return!0;case 196:if(b=C[J++],void 0===b)throw new Error("Unexpected end of buffer");return n(b);case 197:return b=I.getUint16(J),J+=2,n(b);case 198:return b=I.getUint32(J),J+=4,n(b);case 199:// ext 8
return o(C[J++]);case 200:return b=I.getUint16(J),J+=2,o(b);case 201:return b=I.getUint32(J),J+=4,o(b);case 202:if(b=I.getFloat32(J),2<K.useFloat32){// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
let a=ea[(127&C[J])<<1|C[J+1]>>7];return J+=4,(a*b+(0<b?.5:-.5)>>0)/a}return J+=4,b;case 203:return b=I.getFloat64(J),J+=8,b;// uint handlers
case 204:return C[J++];case 205:return b=I.getUint16(J),J+=2,b;case 206:return b=I.getUint32(J),J+=4,b;case 207:return K.int64AsNumber?(b=4294967296*I.getUint32(J),b+=I.getUint32(J+4)):b=I.getBigUint64(J),J+=8,b;// int handlers
case 208:return I.getInt8(J++);case 209:return b=I.getInt16(J),J+=2,b;case 210:return b=I.getInt32(J),J+=4,b;case 211:return K.int64AsNumber?(b=4294967296*I.getInt32(J),b+=I.getUint32(J+4)):b=I.getBigInt64(J),J+=8,b;case 212:if(b=C[J++],114==b)return ba(63&C[J++]);else{let a=N[b];if(a)return a.read?(J++,a.read(e())):a.noBuffer?(J++,a()):a(C.subarray(J,++J));throw new Error("Unknown extension "+b)}case 213:return b=C[J],114==b?(J++,ba(63&C[J++],C[J++])):o(2);case 214:// fixext 4
return o(4);case 215:// fixext 8
return o(8);case 216:// fixext 16
return o(16);case 217:return b=C[J++],M>=J?F.slice(J-L,(J+=b)-L):Y(b);case 218:return b=I.getUint16(J),J+=2,M>=J?F.slice(J-L,(J+=b)-L):Z(b);case 219:return b=I.getUint32(J),J+=4,M>=J?F.slice(J-L,(J+=b)-L):$(b);case 220:return b=I.getUint16(J),J+=2,i(b);case 221:return b=I.getUint32(J),J+=4,i(b);case 222:return b=I.getUint16(J),J+=2,j(b);case 223:return b=I.getUint32(J),J+=4,j(b);default:// negative int
if(224<=a)return a-256;if(void 0===a){let a=new Error("Unexpected end of MessagePack data");throw a.incomplete=!0,a}throw new Error("Unknown MessagePack token "+a);}}}function f(a,b){function c(){// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function
if(c.count++>T){let c=a.read=new Function("r","return function(){return "+(K.freezeData?"Object.freeze":"")+"({"+a.map(a=>V.test(a)?a+":r()":"["+JSON.stringify(a)+"]:r()").join(",")+"})}")(e);return 0===a.highByte&&(a.read=W(b,a.read)),c();// second byte is already read, if there is one so immediately read object
}let d={};for(let b,c=0,f=a.length;c<f;c++)b=a[c],d[b]=e();return K.freezeData?Object.freeze(d):d}return c.count=0,0===a.highByte?W(b,c):c}function g(){let a=q(()=>(C=null,K.getStructures()));return E=K._mergeStructures(a,E)}function h(a){let b;if(16>a&&(b=l(a)))return b;if(64<a&&B)return B.decode(C.subarray(J,J+=a));const c=J+a,d=[];for(b="";J<c;){const a=C[J++];if(0==(128&a))d.push(a);else if(192==(224&a)){// 2 bytes
const b=63&C[J++];d.push((31&a)<<6|b)}else if(224==(240&a)){// 3 bytes
const b=63&C[J++],c=63&C[J++];d.push((31&a)<<12|b<<6|c)}else if(240==(248&a)){// 4 bytes
const b=63&C[J++],c=63&C[J++],e=63&C[J++];let f=(7&a)<<18|b<<12|c<<6|e;65535<f&&(f-=65536,d.push(55296|1023&f>>>10),f=56320|1023&f),d.push(f)}else d.push(a);4096<=d.length&&(b+=_.apply(String,d),d.length=0)}return 0<d.length&&(b+=_.apply(String,d)),b}function i(a){let b=Array(a);for(let c=0;c<a;c++)b[c]=e();return K.freezeData?Object.freeze(b):b}function j(a){if(K.mapsAsObjects){let b={};for(let c=0;c<a;c++)b[p()]=e();return b}else{let b=new Map;for(let c=0;c<a;c++)b.set(e(),e());return b}}function k(a){let b=J,c=Array(a);for(let d=0;d<a;d++){const a=C[J++];if(0<(128&a))return void(J=b);c[d]=a}return _.apply(String,c)}function l(p){if(4>p){if(!(2>p)){let d=C[J++],a=C[J++];if(0<(128&d)||0<(128&a))return void(J-=2);if(3>p)return _(d,a);let b=C[J++];return 0<(128&b)?void(J-=3):_(d,a,b)}if(0===p)return"";else{let b=C[J++];return 1<(128&b)?void(J-=1):_(b)}}else{let q=C[J++],a=C[J++],b=C[J++],c=C[J++];if(0<(128&q)||0<(128&a)||0<(128&b)||0<(128&c))return void(J-=4);if(6>p){if(4===p)return _(q,a,b,c);else{let d=C[J++];return 0<(128&d)?void(J-=5):_(q,a,b,c,d)}}else if(8>p){let d=C[J++],e=C[J++];if(0<(128&d)||0<(128&e))return void(J-=6);if(7>p)return _(q,a,b,c,d,e);let f=C[J++];return 0<(128&f)?void(J-=7):_(q,a,b,c,d,e,f)}else{let d=C[J++],e=C[J++],f=C[J++],g=C[J++];if(0<(128&d)||0<(128&e)||0<(128&f)||0<(128&g))return void(J-=8);if(10>p){if(8===p)return _(q,a,b,c,d,e,f,g);else{let h=C[J++];return 0<(128&h)?void(J-=9):_(q,a,b,c,d,e,f,g,h)}}else if(12>p){let h=C[J++],i=C[J++];if(0<(128&h)||0<(128&i))return void(J-=10);if(11>p)return _(q,a,b,c,d,e,f,g,h,i);let j=C[J++];return 0<(128&j)?void(J-=11):_(q,a,b,c,d,e,f,g,h,i,j)}else{let h=C[J++],i=C[J++],j=C[J++],k=C[J++];if(0<(128&h)||0<(128&i)||0<(128&j)||0<(128&k))return void(J-=12);if(!(14>p)){let l=C[J++],m=C[J++];if(0<(128&l)||0<(128&m))return void(J-=14);if(15>p)return _(q,a,b,c,d,e,f,g,h,i,j,k,l,m);let n=C[J++];return 0<(128&n)?void(J-=15):_(q,a,b,c,d,e,f,g,h,i,j,k,l,m,n)}if(12===p)return _(q,a,b,c,d,e,f,g,h,i,j,k);else{let l=C[J++];return 0<(128&l)?void(J-=13):_(q,a,b,c,d,e,f,g,h,i,j,k,l)}}}}}function m(){let a,b=C[J++];if(192>b)// fixstr
a=b-160;else switch(b){case 217:a=C[J++];break;case 218:a=I.getUint16(J),J+=2;break;case 219:a=I.getUint32(J),J+=4;break;default:throw new Error("Expected string");}return h(a)}function n(a){return K.copyBuffers?// specifically use the copying slice (not the node one)
Uint8Array.prototype.slice.call(C,J,J+=a):C.subarray(J,J+=a)}function o(a){let b=C[J++];if(N[b])return N[b](C.subarray(J,J+=a));throw new Error("Unknown extension type "+b)}function p(){let a=C[J++];if(160<=a&&192>a){if(a-=160,M>=J)// if it has been extracted, must use it (and faster anyway)
return F.slice(J-L,(J+=a)-L);if(!(0==M&&180>D))return X(a)}else return J--,e();let b,c=4095&(a<<5^(1<a?I.getUint16(J):0<a?C[J]:0)),d=aa[c],f=J,g=J+a-3,h=0;if(d&&d.bytes==a){for(;f<g;){if(b=I.getUint32(f),b!=d[h++]){f=1879048192;break}f+=4}for(g+=3;f<g;)if(b=C[f++],b!=d[h++]){f=1879048192;break}if(f===g)return J=f,d.string;g-=3,f=J}for(d=[],aa[c]=d,d.bytes=a;f<g;)b=I.getUint32(f),d.push(b),f+=4;for(g+=3;f<g;)b=C[f++],d.push(b);// for small blocks, avoiding the overhead of the extract call is helpful
let j=16>a?l(a):k(a);return null==j?d.string=X(a):d.string=j}// the registration of the record definition extension (as "r")
// notepack defines extension 0 to mean undefined, so use that as the default here
// registration of bulk record definition?
// currentExtensions[0x52] = () =>
function q(a){let b=D,c=J,d=L,e=M,f=F,g=H,h=G,i=new Uint8Array(C.slice(0,D)),j=E,k=E.slice(0,E.length),l=K,m=S,n=a();return D=b,J=c,L=d,M=e,F=f,H=g,G=h,C=i,S=m,E=j,E.splice(0,E.length,...k),K=l,I=new DataView(C.buffer,C.byteOffset,C.byteLength),n}function r(){C=null,H=null,E=null}function s(a){N[a.type]=a.unpack?a.unpack:a}function t(a,b,c){let d=a.byteLength;if(256>d+1){var{target:e,position:f}=c(4+d);e[f++]=199,e[f++]=d+1}else if(65536>d+1){var{target:e,position:f}=c(5+d);e[f++]=200,e[f++]=d+1>>8,e[f++]=255&d+1}else{var{target:e,position:f,targetView:g}=c(7+d);// plus one for the type byte
e[f++]=201,g.setUint32(f,d+1),f+=4}// "t" for typed array
e[f++]=116,e[f++]=b,e.set(new Uint8Array(a.buffer,a.byteOffset,a.byteLength),f)}function u(a,b){let c=a.byteLength;var d,e;if(256>c){var{target:d,position:e}=b(c+2);d[e++]=196,d[e++]=c}else if(65536>c){var{target:d,position:e}=b(c+3);d[e++]=197,d[e++]=c>>8,d[e++]=255&c}else{var{target:d,position:e,targetView:f}=b(c+5);d[e++]=198,f.setUint32(e,c),e+=4}d.set(a,e)}function v(a,b,c,d){let e=a.length;return 1===e?b[c++]=212:2===e?b[c++]=213:4===e?b[c++]=214:8===e?b[c++]=215:16===e?b[c++]=216:256>e?(b[c++]=199,b[c++]=e):65536>e?(b[c++]=200,b[c++]=e>>8,b[c++]=255&e):(b[c++]=201,b[c++]=e>>24,b[c++]=255&e>>16,b[c++]=255&e>>8,b[c++]=255&e),b[c++]=d,b.set(a,c),c+=e,c}function w(a,b){// insert the ids that need to be referenced for structured clones
let c,d=6*b.length,e=a.length-d;for(b.sort((c,a)=>c.offset>a.offset?1:-1);c=b.pop();){let b=c.offset,f=c.id;a.copyWithin(b+d,b,e),d-=6;let g=b+d;// 'i'
a[g++]=214,a[g++]=105,a[g++]=f>>24,a[g++]=255&f>>16,a[g++]=255&f>>8,a[g++]=255&f,e=b}return a}function x(a,b){if(0<za.length){va.setUint32(za.position+a,ya-za.position-a);let c=za;za=null,b(c[0]),b(c[1])}}function y(a){if(a.Class){if(!a.pack&&!a.write)throw new Error("Extension has no pack or write function");if(a.pack&&!a.type)throw new Error("Extension has no type (numeric code to identify the extension)");oa.unshift(a.Class),na.unshift(a)}s(a)}function*z(a,b){const c=new Ba(b);for(const d of a)yield c.pack(d)}async function*A(a,b){const c=new Ba(b);for await(const d of a)yield c.pack(d)}/**
	 * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects
	 * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.
	 * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator
	 * @param {object} [options] - unpackr options
	 * @returns {IterableIterator|Promise.<AsyncIterableIterator}
	 */var B;try{B=new TextDecoder}catch(a){}var C,D,E,F,G,H,I,J=0,K={},L=0,M=0,N=[],O={useRecords:!1,mapsAsObjects:!0};class P{}const Q=new P;Q.name="MessagePack 0xC1";var R,S=!1,T=2;try{new Function("")}catch(a){// if eval variants are not supported, do not create inline object readers ever
T=1/0}class U{constructor(a){a&&(!1===a.useRecords&&a.mapsAsObjects===void 0&&(a.mapsAsObjects=!0),a.sequential&&!1!==a.trusted&&(a.trusted=!0,!a.structures&&!1!=a.useRecords&&(a.structures=[],!a.maxSharedStructures&&(a.maxSharedStructures=0))),a.structures?a.structures.sharedLength=a.structures.length:a.getStructures&&((a.structures=[]).uninitialized=!0,a.structures.sharedLength=0)),Object.assign(this,a)}unpack(a,b){if(C)// re-entrant execution, save the state and restore it after we do this unpack
return q(()=>(r(),this?this.unpack(a,b):U.prototype.unpack.call(O,a,b)));D=-1<b?b:a.length,J=0,M=0,F=null,G=null,C=a;// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend
// technique for getting data from a database where it can be copied into an existing buffer instead of creating
// new ones
try{I=a.dataView||(a.dataView=new DataView(a.buffer,a.byteOffset,a.byteLength))}catch(b){if(C=null,a instanceof Uint8Array)throw b;throw new Error("Source must be a Uint8Array or Buffer but was a "+(a&&"object"==typeof a?a.constructor.name:typeof a))}if(this instanceof U){if(K=this,this.structures)return E=this.structures,c();(!E||0<E.length)&&(E=[])}else K=O,(!E||0<E.length)&&(E=[]);return c()}unpackMultiple(a,b){let d,e=0;try{S=!0;let f=a.length,g=this?this.unpack(a,f):fa.unpack(a,f);if(b){for(b(g);J<f;)if(e=J,!1===b(c()))return;}else{for(d=[g];J<f;)e=J,d.push(c());return d}}catch(a){throw a.lastPosition=e,a.values=d,a}finally{S=!1,r()}}_mergeStructures(a,b){a=a||[];for(let c,d=0,e=a.length;d<e;d++)c=a[d],c&&(c.isShared=!0,32<=d&&(c.highByte=d-32>>5));for(let c in a.sharedLength=a.length,b||[])if(0<=c){let d=a[c],e=b[c];e&&(d&&((a.restoreStructures||(a.restoreStructures=[]))[c]=d),a[c]=e)}return this.structures=a}decode(a,b){return this.unpack(a,b)}}const V=/^[a-zA-Z_$][a-zA-Z\d_$]*$/,W=(a,b)=>function(){let c=C[J++];if(0===c)return b();let d=32>a?-(a+(c<<5)):a+(c<<5),e=E[d]||g()[d];if(!e)throw new Error("Record id is not defined for "+d);return e.read||(e.read=f(e,a)),e.read()};var X=h,Y=h,Z=h,$=h;var _=String.fromCharCode,aa=Array(4096);const ba=(a,b)=>{var c=e();let d=a;void 0!==b&&(a=32>a?-((b<<5)+a):(b<<5)+a,c.highByte=b);let g=E[a];return g&&g.isShared&&((E.restoreStructures||(E.restoreStructures=[]))[a]=g),E[a]=c,c.read=f(c,d),c.read()};N[0]=()=>{},N[0].noBuffer=!0,N[101]=()=>{let a=e();return(globalThis[a[0]]||Error)(a[1])},N[105]=()=>{// id extension (for structured clones)
let a=I.getUint32(J-4);H||(H=new Map);let b,c=C[J];b=144<=c&&160>c||220==c||221==c?[]:{};let d={target:b};// a placeholder object
H.set(a,d);let f=e();// read the next value as the target object to id
return d.used?Object.assign(b,f):(d.target=f,f);// no cycle, can just use the returned read object
},N[112]=()=>{// pointer extension (for structured clones)
let a=I.getUint32(J-4),b=H.get(a);return b.used=!0,b.target},N[115]=()=>new Set(e());const ca=["Int8","Uint8","Uint8Clamped","Int16","Uint16","Int32","Uint32","Float32","Float64","BigInt64","BigUint64"].map(a=>a+"Array");N[116]=a=>{let b=a[0],c=ca[b];if(!c)throw new Error("Could not find typed array for code "+b);// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned
return new globalThis[c](Uint8Array.prototype.slice.call(a,1).buffer)},N[120]=()=>{let a=e();return new RegExp(a[0],a[1])};const da=[];N[98]=a=>{let b=(a[0]<<24)+(a[1]<<16)+(a[2]<<8)+a[3],c=J;return J+=b-a.length,G=da,G=[m(),m()],G.position0=0,G.position1=0,G.postBundlePosition=J,J=c,e()},N[255]=a=>4==a.length?new Date(1e3*(16777216*a[0]+(a[1]<<16)+(a[2]<<8)+a[3])):8==a.length?new Date(((a[0]<<22)+(a[1]<<14)+(a[2]<<6)+(a[3]>>2))/1e6+1e3*(4294967296*(3&a[3])+16777216*a[4]+(a[5]<<16)+(a[6]<<8)+a[7])):12==a.length?new Date(((a[0]<<24)+(a[1]<<16)+(a[2]<<8)+a[3])/1e6+1e3*((128&a[4]?-281474976710656:0)+1099511627776*a[6]+4294967296*a[7]+16777216*a[8]+(a[9]<<16)+(a[10]<<8)+a[11])):new Date("invalid");const ea=Array(147);// this is a table matching binary exponents to the multiplier to determine significant digit rounding
for(let c=0;256>c;c++)ea[c]=+("1e"+b(45.15-.30103*c));var fa=new U({useRecords:!1});const ga=fa.unpack,ha=fa.unpackMultiple,ia=fa.unpack,ja={NEVER:0,ALWAYS:1,DECIMAL_ROUND:3,DECIMAL_FIT:4};let ka,la=new Float32Array(1),ma=new Uint8Array(la.buffer,0,4);try{ka=new TextEncoder}catch(a){}let na,oa;const pa="undefined"!=typeof Buffer,qa=pa?function(a){return Buffer.allocUnsafeSlow(a)}:Uint8Array,ra=pa?Buffer:Uint8Array,sa=pa?4294967296:2144337920;let ta,ua,va,wa,xa,ya=0,za=null;const Aa=Symbol("record-id");class Ba extends U{constructor(a){super(a),this.offset=0;let b,c,d,e,f=0,g=ra.prototype.utf8Write?function(a,b){return ta.utf8Write(a,b,4294967295)}:!!(ka&&ka.encodeInto)&&function(a,b){return ka.encodeInto(a,ta.subarray(b)).written},h=this;a||(a={});let i=a&&a.sequential,j=a.structures||a.saveStructures,k=a.maxSharedStructures;if(null==k&&(k=j?32:0),8160<k)throw new Error("Maximum maxSharedStructure is 8160");a.structuredClone&&null==a.moreTypes&&(a.moreTypes=!0);let l=a.maxOwnStructures;null==l&&(l=j?32:64),this.structures||!1==a.useRecords||(this.structures=[]);// two byte record ids for shared structures
let m=32<k||64<l+k,n=k+64,o=k+l+64;if(8256<o)throw new Error("Maximum maxSharedStructure + maxOwnStructure is 8192");let p=[],q=0,r=0;this.pack=this.encode=function(a,g){if(ta||(ta=new qa(8192),va=ta.dataView=new DataView(ta.buffer,0,8192),ya=0),wa=ta.length-10,2048>wa-ya?(ta=new qa(ta.length),va=ta.dataView=new DataView(ta.buffer,0,ta.length),wa=ta.length-10,ya=0):ya=2147483640&ya+7,b=ya,e=h.structuredClone?new Map:null,h.bundleStrings&&"string"!=typeof a?(za=[],za.size=1/0):za=null,d=h.structures,d){d.uninitialized&&(d=h._mergeStructures(h.getStructures()));let a=d.sharedLength||0;if(a>k)//if (maxSharedStructures <= 32 && structures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids
throw new Error("Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to "+d.sharedLength);if(!d.transitions){d.transitions=Object.create(null);for(let b,c=0;c<a;c++){if(b=d[c],!b)continue;let a,e=d.transitions;for(let c,d=0,f=b.length;d<f;d++)c=b[d],a=e[c],a||(a=e[c]=Object.create(null)),e=a;e[Aa]=c+64}f=a}i||(d.nextId=a+64)}c&&(c=!1);try{// update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially
if(h.randomAccessStructure?A(a):s(a),za&&x(b,s),h.offset=ya,e&&e.idsToInsert){ya+=6*e.idsToInsert.length,ya>wa&&u(ya),h.offset=ya;let a=w(ta.subarray(b,ya),e.idsToInsert);return e=null,a}return g&Ja?(ta.start=b,ta.end=ya,ta):ta.subarray(b,ya);// position can change if we call pack again in saveStructures, so we get the buffer now
}finally{if(d){10>r&&r++;let e=d.sharedLength||k;if(d.length>e&&(d.length=e),1e4<q)d.transitions=null,r=0,q=0,0<p.length&&(p=[]);else if(0<p.length&&!i){for(let a=0,b=p.length;a<b;a++)p[a][Aa]=0;p=[]}if(c&&h.saveStructures){// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save
let c=ta.subarray(b,ya);return!1===h.saveStructures(d,f)?(h._mergeStructures(h.getStructures()),h.pack(a)):(f=e,c)}}g&Ka&&(ya=b)}};const s=a=>{ya>wa&&(ta=u(ya));var c,d=typeof a;if("string"==d){let d=a.length;if(za&&4<=d&&4096>d){if((za.size+=d)>61440){let a,c=(za[0]?3*za[0].length+za[1].length:0)+10;ya+c>wa&&(ta=u(ya+c)),za.position?(ta[ya]=200,ya+=3,ta[ya++]=98,a=ya-b,ya+=4,x(b,s),va.setUint16(a+b-3,ya-b-a)):(ta[ya++]=214,ta[ya++]=98,a=ya-b,ya+=4),za=["",""],za.size=0,za.position=a}let c=/[\u0080-\uFFFF]/.test(a);return za[c?0:1]+=a,ta[ya++]=193,void s(c?-d:d)}let e=32>d?1:256>d?2:65536>d?3:5;// first we estimate the header size, so we can write to the correct location
let f=3*d;if(ya+f>wa&&(ta=u(ya+f)),64>d||!g){let b,f,g,h=ya+e;for(b=0;b<d;b++)f=a.charCodeAt(b),128>f?ta[h++]=f:2048>f?(ta[h++]=192|f>>6,ta[h++]=128|63&f):55296==(64512&f)&&56320==(64512&(g=a.charCodeAt(b+1)))?(f=65536+((1023&f)<<10)+(1023&g),b++,ta[h++]=240|f>>18,ta[h++]=128|63&f>>12,ta[h++]=128|63&f>>6,ta[h++]=128|63&f):(ta[h++]=224|f>>12,ta[h++]=128|63&f>>6,ta[h++]=128|63&f);c=h-ya-e}else c=g(a,ya+e);32>c?ta[ya++]=160|c:256>c?(2>e&&ta.copyWithin(ya+2,ya+1,ya+1+c),ta[ya++]=217,ta[ya++]=c):65536>c?(3>e&&ta.copyWithin(ya+3,ya+2,ya+2+c),ta[ya++]=218,ta[ya++]=c>>8,ta[ya++]=255&c):(5>e&&ta.copyWithin(ya+5,ya+3,ya+3+c),ta[ya++]=219,va.setUint32(ya,c),ya+=4),ya+=c}else if("number"===d){if(a>>>0===a)64>a||128>a&&!1===this.useRecords?ta[ya++]=a:256>a?(ta[ya++]=204,ta[ya++]=a):65536>a?(ta[ya++]=205,ta[ya++]=a>>8,ta[ya++]=255&a):(ta[ya++]=206,va.setUint32(ya,a),ya+=4);else if(a>>0===a)-32<=a?ta[ya++]=256+a:-128<=a?(ta[ya++]=208,ta[ya++]=a+256):-32768<=a?(ta[ya++]=209,va.setInt16(ya,a),ya+=2):(ta[ya++]=210,va.setInt32(ya,a),ya+=4);else{let b;if(0<(b=this.useFloat32)&&4294967296>a&&-2147483648<=a){ta[ya++]=202,va.setFloat32(ya,a);let c;if(4>b||// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
(c=a*ea[(127&ta[ya])<<1|ta[ya+1]>>7])>>0===c)return void(ya+=4);// move back into position for writing a double
ya--}ta[ya++]=203,va.setFloat64(ya,a),ya+=8}}else if("object"===d){if(!a)ta[ya++]=192;else{if(e){let c=e.get(a);if(c){if(!c.id){let a=e.idsToInsert||(e.idsToInsert=[]);c.id=a.push(c)}return ta[ya++]=214,ta[ya++]=112,va.setUint32(ya,c.id),void(ya+=4)}e.set(a,{offset:ya-b})}let d=a.constructor;if(d===Object)t(a,!0);else if(d===Array){c=a.length,16>c?ta[ya++]=144|c:65536>c?(ta[ya++]=220,ta[ya++]=c>>8,ta[ya++]=255&c):(ta[ya++]=221,va.setUint32(ya,c),ya+=4);for(let b=0;b<c;b++)s(a[b])}else if(d===Map){c=a.size,16>c?ta[ya++]=128|c:65536>c?(ta[ya++]=222,ta[ya++]=c>>8,ta[ya++]=255&c):(ta[ya++]=223,va.setUint32(ya,c),ya+=4);for(let[b,c]of a)s(b),s(c)}else{for(let b,c=0,d=na.length;c<d;c++)if(b=oa[c],a instanceof b){let b=na[c];if(b.write)return b.type&&(ta[ya++]=212,ta[ya++]=b.type,ta[ya++]=0),void s(b.write.call(this,a));let d=ta,e=va,f=ya;ta=null;let g;try{g=b.pack.call(this,a,a=>(ta=d,d=null,ya+=a,ya>wa&&u(ya),{target:ta,targetView:va,position:ya-a}),s)}finally{d&&(ta=d,va=e,ya=f,wa=ta.length-10)}return void(g&&(g.length+ya>wa&&u(g.length+ya),ya=v(g,ta,ya,b.type)))}// no extension found, write as object
t(a,!a.hasOwnProperty)}}}else if("boolean"===d)ta[ya++]=a?195:194;else if("bigint"===d){if(a<BigInt(1)<<BigInt(63)&&a>=-(BigInt(1)<<BigInt(63)))ta[ya++]=211,va.setBigInt64(ya,a);else if(a<BigInt(1)<<BigInt(64)&&0<a)ta[ya++]=207,va.setBigUint64(ya,a);else// overflow
if(this.largeBigIntToFloat)ta[ya++]=203,va.setFloat64(ya,+a);else throw new RangeError(a+" was too large to fit in MessagePack 64-bit integer format, set largeBigIntToFloat to convert to float-64");ya+=8}else if("undefined"===d)this.encodeUndefinedAsNil?ta[ya++]=192:(ta[ya++]=212,ta[ya++]=0,ta[ya++]=0);else if("function"===d)s(this.writeFunction&&this.writeFunction());else throw new Error("Unknown type: "+d)},t=!1===this.useRecords?this.variableMapSize?a=>{// this method is slightly slower, but generates "preferred serialization" (optimally small for smaller objects)
let b=Object.keys(a),c=b.length;16>c?ta[ya++]=128|c:65536>c?(ta[ya++]=222,ta[ya++]=c>>8,ta[ya++]=255&c):(ta[ya++]=223,va.setUint32(ya,c),ya+=4);let d;for(let e=0;e<c;e++)s(d=b[e]),s(a[d])}:(a,c)=>{ta[ya++]=222;// always using map 16, so we can preallocate and set the length afterwards
let d=ya-b;ya+=2;let e=0;for(let b in a)(c||a.hasOwnProperty(b))&&(s(b),s(a[b]),e++);ta[d++ +b]=e>>8,ta[d+b]=255&e}:a.progressiveRecords&&!m?// this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)
(a,c)=>{let e,f,g=d.transitions||(d.transitions=Object.create(null)),h=ya++-b;for(let i in a)if(c||a.hasOwnProperty(i)){if(e=g[i],e)g=e;else{// record doesn't exist, create full new record and insert it
let c=Object.keys(a),j=g;g=d.transitions;let k=0;for(let a,b=0,d=c.length;b<d;b++)a=c[b],e=g[a],e||(e=g[a]=Object.create(null),k++),g=e;h+b+1==ya?(ya--,y(g,c,k)):// otherwise we need to insert the record, moving existing data after the record
z(g,c,h,k),f=!0,g=j[i]}s(a[i])}if(!f){let c=g[Aa];c?ta[h+b]=c:z(g,Object.keys(a),h,0)}}:(a,b)=>{let c,e=d.transitions||(d.transitions=Object.create(null)),f=0;for(let d in a)(b||a.hasOwnProperty(d))&&(c=e[d],c||(c=e[d]=Object.create(null),f++),e=c);let g=e[Aa];// now write the values
for(let c in g?96<=g&&m?(ta[ya++]=(31&(g-=96))+96,ta[ya++]=g>>5):ta[ya++]=g:y(e,e.__keys__||Object.keys(a),f),a)(b||a.hasOwnProperty(c))&&s(a[c])},u=a=>{var c=Math.min,d=Math.round,e=Math.max;let f;if(16777216<a){// special handling for really large buffers
if(a-b>sa)throw new Error("Packed buffer would be larger than maximum buffer size");f=c(sa,4096*d(e((a-b)*(67108864<a?1.25:2),4194304)/4096))}else// faster handling for smaller buffers
f=(e(a-b<<2,ta.length-1)>>12)+1<<12;let g=new qa(f);return va=g.dataView=new DataView(g.buffer,0,f),a=c(a,ta.length),ta.copy?ta.copy(g,0,b,a):g.set(ta.slice(b,a)),ya-=b,b=0,wa=g.length-10,ta=g},y=(a,b,e)=>{let f=d.nextId;f||(f=64),f<n&&this.shouldShareStructure&&!this.shouldShareStructure(b)?(f=d.nextOwnId,!(f<o)&&(f=n),d.nextOwnId=f+1):(f>=o&&(// cycle back around
f=n),d.nextId=f+1);let g=b.highByte=96<=f&&m?f-96>>5:-1;a[Aa]=f,a.__keys__=b,d[f-64]=b,f<n?(b.isShared=!0,d.sharedLength=f-63,c=!0,0<=g?(ta[ya++]=(31&f)+96,ta[ya++]=g):ta[ya++]=f):(0<=g?(ta[ya++]=213,ta[ya++]=114,ta[ya++]=(31&f)+96,ta[ya++]=g):(ta[ya++]=212,ta[ya++]=114,ta[ya++]=f),e&&(q+=r*e),p.length>=l&&(p.shift()[Aa]=0),p.push(a),s(b))},z=(a,c,d,e)=>{let f=ta,g=ya,h=wa,i=b;ta=ua,ya=0,b=0,ta||(ua=ta=new qa(8192)),wa=ta.length-10,y(a,c,e),ua=ta;let j=ya;if(ta=f,ya=g,wa=h,b=i,1<j){let a=ya+j-1;a>wa&&u(a);let c=d+b;ta.copyWithin(c+j,c+1,ya),ta.set(ua.slice(0,j),c),ya=a}else ta[d+b]=ua[0]},A=a=>{let b=xa();return 0===b?t(a,!0):void(ya=b)}}useBuffer(a){// this means we are finished using our own buffer and we can write over it safely
ta=a,va=new DataView(ta.buffer,ta.byteOffset,ta.byteLength),ya=0}clearSharedData(){this.structures&&(this.structures=[])}}oa=[Date,Set,Error,RegExp,ArrayBuffer,Object.getPrototypeOf(Uint8Array.prototype).constructor/*TypedArray*/,P],na=[{pack(a,c,d){let e=a.getTime()/1e3;if((this.useTimestamp32||0===a.getMilliseconds())&&0<=e&&4294967296>e){// Timestamp 32
let{target:a,targetView:b,position:d}=c(6);a[d++]=214,a[d++]=255,b.setUint32(d,e)}else if(0<e&&4294967296>e){// Timestamp 64
let{target:b,targetView:d,position:f}=c(10);b[f++]=215,b[f++]=255,d.setUint32(f,4e6*a.getMilliseconds()+(e/1e3/4294967296>>0)),d.setUint32(f+4,e)}else if(isNaN(e)){if(this.onInvalidDate)return c(0),d(this.onInvalidDate());// Intentionally invalid timestamp
let{target:a,targetView:b,position:e}=c(3);a[e++]=212,a[e++]=255,a[e++]=255}else{// Timestamp 96
let{target:d,targetView:f,position:g}=c(15);d[g++]=199,d[g++]=12,d[g++]=255,f.setUint32(g,1e6*a.getMilliseconds()),f.setBigInt64(g+4,BigInt(b(e)))}}},{pack(a,b,c){let d=Array.from(a),{target:e,position:f}=b(this.moreTypes?3:0);this.moreTypes&&(e[f++]=212,e[f++]=115,e[f++]=0),c(d)}},{pack(a,b,c){let{target:d,position:e}=b(this.moreTypes?3:0);this.moreTypes&&(d[e++]=212,d[e++]=101,d[e++]=0),c([a.name,a.message])}},{pack(a,b,c){let{target:d,position:e}=b(this.moreTypes?3:0);this.moreTypes&&(d[e++]=212,d[e++]=120,d[e++]=0),c([a.source,a.flags])}},{pack(a,b){this.moreTypes?t(a,16,b):u(pa?Buffer.from(a):new Uint8Array(a),b)}},{pack(a,b){let c=a.constructor;c!==ra&&this.moreTypes?t(a,ca.indexOf(c.name),b):u(a,b)}},{pack(a,b){// specific 0xC1 object
let{target:c,position:d}=b(1);c[d]=193}}];let Ca=new Ba({useRecords:!1});const Da=Ca.pack,Ea=Ca.pack,{NEVER:Fa,ALWAYS:Ga,DECIMAL_ROUND:Ha,DECIMAL_FIT:Ia}=ja,Ja=512,Ka=1024;a.ALWAYS=Ga,a.C1=Q,a.DECIMAL_FIT=Ia,a.DECIMAL_ROUND=Ha,a.Decoder=U,a.Encoder=Ba,a.FLOAT32_OPTIONS=ja,a.NEVER=Fa,a.Packr=Ba,a.REUSE_BUFFER_MODE=Ja,a.Unpackr=U,a.addExtension=y,a.clearSource=r,a.decode=ia,a.decodeIter=function(a,b={}){if(!a||"object"!=typeof a)throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise");const c=new U(b);let d;const e=a=>{let b;// if there's incomplete data from previous chunk, concatinate and try again
d&&(a=Buffer.concat([d,a]),d=void 0);try{b=c.unpackMultiple(a)}catch(c){if(c.incomplete)d=a.slice(c.lastPosition),b=c.values;else throw c}return b};if("function"==typeof a[Symbol.iterator])return function*(){for(const b of a)yield*e(b)}();return"function"==typeof a[Symbol.asyncIterator]?async function*(){for await(const b of a)yield*e(b)}():void 0},a.encode=Ea,a.encodeIter=/**
	 * Given an Iterable first argument, returns an Iterable where each value is packed as a Buffer
	 * If the argument is only Async Iterable, the return value will be an Async Iterable.
	 * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object
	 * @param {options} [options] - msgpackr pack options
	 * @returns {IterableIterator|Promise.<AsyncIterableIterator>}
	 */function(a,b={}){if(!a||"object"!=typeof a)throw new Error("first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable");else{if("function"==typeof a[Symbol.iterator])return z(a,b);if("function"==typeof a.then||"function"==typeof a[Symbol.asyncIterator])return A(a,b);throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise")}},a.isNativeAccelerationEnabled=!1,a.mapsAsObjects=!0,a.pack=Da,a.roundFloat32=function(a){la[0]=a;let b=ea[(127&ma[3])<<1|ma[2]>>7];return(b*a+(0<a?.5:-.5)>>0)/b},a.unpack=ga,a.unpackMultiple=ha,a.useRecords=!1,Object.defineProperty(a,"__esModule",{value:!0})});
